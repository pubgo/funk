package internal

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"github.com/pubgo/funk/proto/errorpb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

const errorPbPkg = "github.com/pubgo/funk/proto/errorpb"

// GenerateFile generates a .errors.pb.go file containing service definitions.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + ".errors.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	genFile := jen.NewFile(string(file.GoPackageName))
	genFile.HeaderComment("Code generated by protoc-gen-go-errors. DO NOT EDIT.")
	genFile.HeaderComment("versions:")
	genFile.HeaderComment(fmt.Sprintf("- protoc-gen-go-errors %s", version))
	genFile.HeaderComment(fmt.Sprintf("- protoc               %s", protocVersion(gen)))
	if file.Proto.GetOptions().GetDeprecated() {
		genFile.HeaderComment(fmt.Sprintf("%s is a deprecated file.", file.Desc.Path()))
	} else {
		genFile.HeaderComment(fmt.Sprintf("source: %s", file.Desc.Path()))
	}

	genFile.Comment("This is a compile-time assertion to ensure that this generated file")
	genFile.Comment("is compatible with the grpc package it is being compiled against.")
	genFile.Comment("Requires gRPC-Go v1.32.0 or later.")
	genFile.Id("const _ =").Qual("google.golang.org/grpc", "SupportPackageIsVersion7")
	g.Skip()

	for i := range file.Enums {
		m := file.Enums[i]
		tag, ok := proto.GetExtension(m.Desc.Options(), errorpb.E_Opts).(*errorpb.Options)
		if !ok || tag == nil || !tag.GetGen() {
			continue
		}

		g.Unskip()

		baseName := strcase.ToCamel(tag.Name)

		for _, codeName := range m.Values {
			name := strings.ToLower(fmt.Sprintf("%s.%s",
				file.Desc.Package(),
				strcase.ToSnake(string(codeName.Desc.Name())),
			))

			statusName := "OK"
			if tag.DefaultCode != 0 && int32(codeName.Desc.Number()) != 0 {
				statusName = tag.DefaultCode.String()
			}

			field, ok := proto.GetExtension(codeName.Desc.Options(), errorpb.E_Field).(*errorpb.Fields)
			if ok && field != nil {
				statusName = field.Code.String()
				if field.Name != "" {
					name = field.Name
				}
			}

			// comment
			rr := string(codeName.Desc.Name())
			if codeName.Comments.Leading.String() != "" {
				rr = codeName.Comments.Leading.String()
				rr = strings.Trim(strings.TrimSpace(rr), "/")
			}

			if field != nil && field.Msg != "" {
				rr = field.Msg
			}

			rr = strings.ToLower(strcase.ToSnake(rr))
			rr = strings.ReplaceAll(rr, "_", " ")
			rr = strings.TrimSpace(strings.ReplaceAll(rr, "  ", " "))

			num := int32(codeName.Desc.Number())
			errCodeName := baseName + "ErrCode" + string(codeName.Desc.Name())
			genFile.Var().
				Id(errCodeName).
				Id("=").
				Op("&").Qual(errorPbPkg, "ErrCode").
				Values(jen.Dict{
					jen.Id("StatusCode"): jen.Qual(errorPbPkg, "Code_"+statusName),
					jen.Id("Name"):       jen.Lit(name),
					jen.Id("Code"):       jen.Lit(num),
					jen.Id("Message"):    jen.Lit(rr),
				})
			genFile.Var().Id("_").Op("=").
				Qual("github.com/pubgo/funk/errors", "RegisterErrCodes").
				Call(jen.Id(errCodeName)).Line()
		}
	}

	g.P(genFile.GoString())
	return g
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}
