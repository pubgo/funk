package internal

import (
	"fmt"
	"github.com/pubgo/funk/log"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"github.com/pubgo/funk/errorpb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

const errorPkg = "github.com/pubgo/funk/errors"

// GenerateFile generates a .errors.pb.go file containing service definitions.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + ".errors.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	genFile := jen.NewFile(string(file.GoPackageName))
	genFile.HeaderComment("Code generated by protoc-gen-lava-errors. DO NOT EDIT.")
	genFile.HeaderComment("versions:")
	genFile.HeaderComment(fmt.Sprintf("- protoc-gen-lava-errors %s", version))
	genFile.HeaderComment(fmt.Sprintf("- protoc                 %s", protocVersion(gen)))
	if file.Proto.GetOptions().GetDeprecated() {
		genFile.HeaderComment(fmt.Sprintf("%s is a deprecated file.", file.Desc.Path()))
	} else {
		genFile.HeaderComment(fmt.Sprintf("source: %s", file.Desc.Path()))
	}

	genFile.Comment("This is a compile-time assertion to ensure that this generated file")
	genFile.Comment("is compatible with the grpc package it is being compiled against.")
	genFile.Comment("Requires gRPC-Go v1.32.0 or later.")
	genFile.Id("const _ =").Qual("google.golang.org/grpc", "SupportPackageIsVersion7")
	g.Skip()

	for i := range file.Enums {
		m := file.Enums[i]
		var tag, ok = proto.GetExtension(m.Desc.Options(), errorpb.E_Opts).(*errorpb.GenStatus)
		if !ok || tag == nil || !tag.GenEnable {
			continue
		}

		g.Unskip()

		for j := range m.Values {
			codeName := m.Values[j]
			log.Info().Msg(fmt.Sprintln(file.Desc.Package(), codeName.GoIdent.GoName, codeName.Desc.Name(), codeName.Desc.Index(), codeName.Desc.Number(), codeName.Comments.Leading.String()))
			tag, ok = proto.GetExtension(codeName.Desc.Options(), errorpb.E_Field).(*errorpb.GenStatus)
			if ok && tag != nil {
				log.Info().Msg(fmt.Sprintln(tag.Code.String(), tag.Code))
			}

			var bizCode = strings.ToLower(fmt.Sprintf("%s.%s.%s",
				file.Desc.Package(),
				strings.TrimSuffix(string(m.Desc.Name()), "ErrCode"),
				strcase.ToSnake(string(codeName.Desc.Name())),
			))

			// comment
			var rr = strings.TrimSpace(strings.ToLower(string(codeName.Desc.Name())))
			rr = strings.Join(strings.Split(rr, "_"), " ")
			if codeName.Comments.Leading.String() != "" {
				rr = codeName.Comments.Leading.String()
				rr = strings.TrimSpace(strings.Trim(strings.TrimSpace(rr), "/"))
			}

			genFile.Var().Id(
				fmt.Sprintf("Err%s%s", strings.TrimSuffix(string(m.Desc.Name()), "ErrCode"), string(codeName.Desc.Name())),
			).Op("=").Qual(errorPkg, "WrapBizCode").ParamsFunc(func(group *jen.Group) {
				group.Qual(errorPkg, "WrapReason").ParamsFunc(func(group *jen.Group) {
					group.Qual(errorPkg, "New").Params(jen.Lit(rr))
					group.Lit(rr)
				})
				group.Lit(bizCode)
			})
		}
	}

	g.P(genFile.GoString())
	return g
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}
